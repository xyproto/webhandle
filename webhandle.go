package webhandle

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"mime"
	"net/http"
	"path/filepath"
	"strings"

	"github.com/drbawb/mustache"
	"github.com/xyproto/instapage"
	"github.com/xyproto/onthefly"
)

type (
	TemplateValueGenerator func(w http.ResponseWriter, req *http.Request) onthefly.TemplateValues
)

// type http.HandlerFunc er heller en struct som implementerer http.Handler interfacet (har en ServeHTTP func)

// Caching
var globalStringCache map[string]string

// Create a web.go compatible function that returns a string that is the HTML for this page
func GenerateHTML(page *onthefly.Page) http.HandlerFunc {
	return func(w http.ResponseWriter, req *http.Request) {
		w.Header().Add("Content-Type", "text/html")
		fmt.Fprint(w, page.GetXML(true))
	}
}

// Create a web.go compatible function that returns a string that is the HTML for this page
func GenerateHTMLwithTemplate(page *onthefly.Page, tvg TemplateValueGenerator) http.HandlerFunc {
	return func(w http.ResponseWriter, req *http.Request) {
		w.Header().Add("Content-Type", "text/html")
		values := tvg(w, req)
		fmt.Fprint(w, mustache.Render(page.GetXML(true), values))
	}
}

// Create a web.go compatible function that returns a string that is the CSS for this page
func GenerateCSS(page *onthefly.Page) http.HandlerFunc {
	return func(w http.ResponseWriter, req *http.Request) {
		w.Header().Add("Content-Type", "text/css")
		fmt.Fprint(w, page.GetCSS())
	}
}

// Create a web.go compatible function that returns a string that is the XML for this page
func GenerateXML(page *onthefly.Page) http.HandlerFunc {
	return func(w http.ResponseWriter, req *http.Request) {
		w.Header().Add("Content-Type", "text/xml")
		//w.Header().Add("Content-Type", "application/xml") // for human unreadable content
		fmt.Fprint(w, page.GetXML(false))
	}
}

// Creates a page based on the contents of "error.log". Useful for showing compile errors while creating an application.
func NewGenerateErrorHandler(errorfilename string) http.HandlerFunc {
	return func(w http.ResponseWriter, req *http.Request) {
		data, err := ioutil.ReadFile(errorfilename)
		if err != nil {
			fmt.Fprint(w, instapage.Message("Good", "No errors"))
			return
		}
		errors := strings.Replace(string(data), "\n", "</br>", -1)
		fmt.Fprint(w, instapage.Message("Errors", errors))
	}
}

// Takes a filename and returns a function that can handle the request
func File(filename string) func(w http.ResponseWriter, req *http.Request) {
	var extension string
	if strings.Contains(filename, ".") {
		extension = filepath.Ext(filename)
	}
	return func(w http.ResponseWriter, req *http.Request) {
		if extension != "" {
			// TODO: Check if TypeByExtension returned something sensible
			w.Header().Add("Content-Type", mime.TypeByExtension(extension))
		}
		// TODO: Don't ignore errors
		filebytes, _ := ioutil.ReadFile(filename)
		buf := bytes.NewBuffer(filebytes)
		fmt.Fprint(w, buf.String())
	}
}

// Takes an url and a filename and offers that file at the given url
func PublishFile(mux *http.ServeMux, url, filename string) {
	mux.HandleFunc(url, File(filename))
}

// Takes a filename and offers that file at the root url
func PublishRootFile(mux *http.ServeMux, filename string) {
	mux.HandleFunc("/"+filename, File(filename))
}

// Expose the HTML and CSS generated by a page building function to the two given urls
func NewPublishPage(mux *http.ServeMux, htmlurl, cssurl string, buildfunction func(string) *onthefly.Page) {
	page := buildfunction(cssurl)
	mux.HandleFunc(htmlurl, GenerateHTML(page))
	mux.HandleFunc(cssurl, GenerateCSS(page))
}

func Publish(mux *http.ServeMux, url, filename string, cache bool) {
	if cache {
		mux.HandleFunc(url, CacheWrapper(url, File(filename)))
	} else {
		mux.HandleFunc(url, File(filename))
	}
}

// For a NotFound handler, look at net/http
