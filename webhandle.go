// Serve webpages with onthefly and http
package webhandle

import (
	"bytes"
	"fmt"
	. "github.com/xyproto/onthefly"
	"io/ioutil"
	"mime"
	"net/http"
	"path/filepath"
	"strings"
)

type HandleFunc func(http.ResponseWriter, *http.Request)

type (
	// Various function signatures for handling requests
	WebHandle              (func(w http.ResponseWriter, r *http.Request, val string) string)
	SimpleContextHandle    (func(w http.ResponseWriter, r *http.Request) string)
	TemplateValueGenerator func(w http.ResponseWriter, r *http.Request) TemplateValues
)

// Create a web.go compatible function that returns a string that is the HTML for this page
func GenerateHTML(page *Page) HandleFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		fmt.Fprintf(w, "%s", page.GetXML(true))
	}
}

// Create a web.go compatible function that returns a string that is the CSS for this page
func GenerateCSS(page *Page) HandleFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		w.Header().Add("Content-Type", "text/css")
		fmt.Fprintf(w, "%s", page.GetCSS())
	}
}

// Create a web.go compatible function that returns a string that is the XML for this page
func GenerateXML(page *Page) HandleFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		w.Header().Add("Content-Type", "text/xml")
		fmt.Fprintf(w, "%s", page.GetXML(false))
	}
}

// Creates a page based on the contents of "error.log". Useful for showing compile errors while creating an application.
func GenerateErrorHandle(errorfilename string) HandleFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		data, err := ioutil.ReadFile(errorfilename)
		if err != nil {
			errors := strings.Replace(string(data), "\n", "</br>", -1)
			fmt.Fprintf(w, "%s", Message("Errors", errors))
			return
		}
		fmt.Fprintf(w, "%s", Message("Good", "No errors"))
	}
}

// Handles pages that are not found
func NotFound(val string) HandleFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		fmt.Fprintf(w, "%s", Message("No", "Page not found"))
	}
}

// Takes a filename and returns a function that can handle the request
func File(filename string) HandleFunc {
	var extension string
	if strings.Contains(filename, ".") {
		extension = filepath.Ext(filename)
	}
	return func(w http.ResponseWriter, r *http.Request) {
		if extension != "" {
			w.Header().Add("Content-Type", mime.TypeByExtension("."+extension))
		}
		imagebytes, _ := ioutil.ReadFile(filename)
		buf := bytes.NewBuffer(imagebytes)
		// TODO: Write bytes directly
		fmt.Fprintf(w, "%s", buf.String())
	}
}

// Takes an url and a filename and offers that file at the given url
func PublishFile(mux *http.ServeMux, url, filename string) {
	mux.HandleFunc(url, File(filename))
}

// Takes a filename and offers that file at the root url
func PublishRootFile(mux *http.ServeMux, filename string) {
	mux.HandleFunc("/"+filename, File(filename))
}

// Expose the HTML and CSS generated by a page building function to the two given urls
func PublishPage(mux *http.ServeMux, htmlurl, cssurl string, buildfunction func(string) *Page) {
	page := buildfunction(cssurl)
	mux.HandleFunc(htmlurl, GenerateHTML(page))
	mux.HandleFunc(cssurl, GenerateCSS(page))
}

// Serve a static file
func Publish(mux *http.ServeMux, url, filename string) {
	mux.HandleFunc(url, File(filename))
}
